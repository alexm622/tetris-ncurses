/* License generated by licensor(https://github.com/Marvin9/licensor).

 alexm622/tetris-ncurses
 Copyright (C) 2021  Alexander Comeau

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU Affero General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/* triangle.c */

#include <curses.h>
#include <locale.h>
#include <signal.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

#include <main.h>

#include <blocks.h>
#include <game.h>
#include <gui.h>

#define _BSD_SOURCE
int maxlines, maxcols;
Playfield *p;
WINDOW *tetris_win;
Block b;
int score = 0;
bool drop = false;
bool block_update = true;
bool go = false;
int dx, dy;
int level = 0;
int rot = 0;
/**
 * @brief handle the ctrl+c from user and clear memory on ctrl-c
 *
 * @param signum
 */
void signal_callback_handler(int signum) {
  endwin();
  freePlayfield(p);
  freeBlockElements(&b);
  exit(0);
}
/**
 * @brief capture the gameover event
 *
 * @param signum
 */
void signal_term_handler(int signum) {
  endwin();
  freePlayfield(p);
  freeBlockElements(&b);
  // do something for game over eventually
  exit(0);
}

/**
 * @brief the main entry point of the program
 *
 * @return int return code
 */
int main(void) {
  signal(SIGINT, signal_callback_handler);
  curs_set(FALSE);
  setlocale(LC_ALL, "");
  srand(time(NULL));

  /* initialize curses */

  initscr();
  cbreak();
  noecho();

  clear();

  // the update loop
  tetris_win = draw_gui(0, 0);
  keypad(tetris_win, true);
  nodelay(tetris_win, true);
  cbreak();
  refresh();

  b = initBlock(blockGenerator());
  p = initialize_playfield(WIDTH, HEIGHT);
  // loop that updates the screen at a constant rate
  while (1) {
    int down = wgetch(tetris_win);
    switch (down) {
    case KEY_UP:
      rot = 1;
      break;
    case KEY_DOWN:
      dy = 2;
      break;
    case KEY_LEFT:
      dx = -1;
      break;
    case KEY_RIGHT:
      dx = 1;
      break;
    case ' ':
      drop = true;
      break;
    default:
      dy = 1;
      dx = 0;
      break;
    }
    tick();
    if (go) {
      break;
    }
    update();
    flushinp();
    // TODO make this use a deltatime variant?
    // or implement nanosleep()
    usleep(100000);
    // TODO move this to its own method, and move it into the tick function
  }
  refresh();

  getch();
  endwin();

  signal_callback_handler(0);
}
/**
 * @brief the update method that is called to redraw the gui
 *
 */
void update() {
  maxlines = LINES - 1;
  maxcols = COLS - 1;
  draw_gui(0, 0);
  draw_score(score);
  draw_playfield(p);
  draw_block(b);

  refresh();
}
/**
 * @brief update gamefield objects/positions
 *
 */
void tick() {
  tick_gamefield();
  score += inc_score(checkPlayfield(p), level);
}
/**
 * @brief update the gamefield
 *
 */
void tick_gamefield() {
  if (block_update) {
    bool bx = !shiftBlockX(b, dx);
    bool by = !shiftBlockY(b, dy);

    if (!bx) {
      if (playfieldCollisionCheckX(b, p, dx)) {
        if (by || !playfieldCollisionCheckY(b, p, dy)) {
          addToPlayfield(&b, p);
          b = initBlock(blockGenerator());
        }
      }
    }
    block_update = false;
  } else {
    if (rot != 0) {
      rotateBlock(&b, rot);
    }
    block_update = !updateBlock(b, p, dy, dx, drop);
    if (drop) {
      addToPlayfield(&b, p);
      b = initBlock(blockGenerator());
    }
    drop = false;
  }
  clear();
  return;
}
